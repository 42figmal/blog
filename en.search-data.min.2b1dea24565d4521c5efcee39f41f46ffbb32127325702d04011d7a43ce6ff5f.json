[{"id":0,"href":"/blog/docs/ProductDesign/TheTribunus/Information/","title":"Information","section":"TheTribunus","content":"asd\n"},{"id":1,"href":"/blog/docs/CS/Algorithm/Information/","title":"PrefixSum_누적합","section":"Algorithm","content":"asd\n"},{"id":2,"href":"/blog/docs/ProductDesign/Sesac/Information/","title":"[1주차] 서비스 기획자 커리어","section":"SesacX러닝스푼즈 IT 서비스 기획자","content":" [1주차] 서비스 기획자 커리어 마인드 셋 # 서비스 기획 # 업무 단계, 실무에서의 사이클 # 현업자 분들에게 가장 궁금한 것은 역시나 실무가 어떤 사이클로 돌아가는지가 아닐까?\n실무 사이클 ### 1. 문제의 발견 - 직접 서비스를 이용해보면서 불편사항 찾기 - 구글, 네이버 등 타사에도 비슷한 기능이 있는지 마켓리서치 - 베치마킹 시 유명 서비스에서의 특정 페이지 또는 기능으로 범위를 한정 - 주니어 시절 아직 해당 서비스에 익숙하지 않을 때의 신선한 시선을 기억 2. 요구사항 분석 # 당장 해결이 불가능하더라도 분석서 형식으로 정리 후 사내 공유가 가능한 플랫폼에 아카이빙 동일한 불만사항이 수차례 접수되면 작업 우선순위를 높여서 진행 3. 상위기획 # 구체적인 정책과 방안을 정하는 과정 많은 요구사항 중 실제 진행할 프로젝트를 팀 회의로 결정 개발자와 협의를 위한 최초 문서로 작업 방향성을 공유 기능명세서, 메뉴구조도, 케이스별 정책 등의 자료가 추가되기도..! 4. 상세기획 # 표지 / 기획안 히스토리 / 개요 / 플로우차트 / 화면 세부 설명 등으로 진행. 협업하는 개발자/디자이너가 시니어/주니어인지에 따라 기획안의 디테일과 자세함이 달라짐. 기획안에 디자인을 하지말자! 협업자의 고유의 영역을 침범하지 말 것. 5. 개발 중 커뮤니케이션 # 범위가 모호하고 책임범위가 불분명한 경우 담당자(디자이너/개발자)와 무조건 협의하기. 6. QA 테스트 # 규모가 작은 스타트업에서는 기획자가 QA까지 진행하는 경우가 대부분. 본인이 작성한 기획안대로 구현되는지 테스트 진행 (웹, 모바일, 다양한 브라우저, 기종) 특히 카카오톡 인앱 브라우저나 네이버 인앱 브라우저 주의! 버그리포트 작성 시 화면 녹화 영상이나 오류사진을 첨부하면 더더욱 좋음! 7. 서비스 오픈 # 오픈 후 서비스 모니터링, 특히 테스트 당시 오류있었던 항목들 위주로 재점검. 오픈 후 7일 이내 프로젝트 회고 회의 진행. 범인찾기가 아닌 개선점을 찾는 시간으로! 개발자가 좋아하는 상세 기획안 # 명확할 것. 모호한 표현 없애기. 정해진 것, 변경 가능성 있는 것 기획안에 명시하기. (주로 데이터 구조에 연관된 것) 케이스별로 결과가 달리지는 기능이라면 플로우 차트로 도식화하기. 예외케이스들 # 이용자들은 기획자가 설계한 프로세스 순으로 서비스를 이용하지 않음. 우선 정상 시나리오 순으로 상세 기획안 작성 후 예외 케이스들 체크하기. 초기값, 노출방식, 글자 수 제한, 로딩 중, 삭제된 컨텐츠, 이용자별 권한, 키보드 액션 등. 실습 # 작성중\n출처 유니콘 기업 현직자에게 배우는 IT 서비스 기획자 취업 캠프 락홀릭 선생님의 서비스 기획자 커리어 마인드셋 / 서비스 기획 프로세스 수업\n"},{"id":3,"href":"/blog/docs/ProductDesign/SwimNearMe/Information/","title":"Information","section":"SwimNearMe","content":" 헤드라인 HeadLine # 헤드라인 2 # 헤드라인 3 # 헤드라인 4 # 안녕하세요 안녕하세요 hello hello\n#include\u0026lt;stdio.h\u0026gt; "},{"id":4,"href":"/blog/docs/CS/Swift/init/","title":"생성자","section":"Swift","content":" Init # 클래스 안의 함수를 매서드라고 부른다. 매서드 중 클래스내 변수를 초기화하는 함수를 생성자 라고 부른다.\n클래스가 품고있는 속성들이 많아질 경우 사용시 일일히 초기화하기 어렵기 때문에 우리는 초기화를 도와주는 생성자를 사용한다!\n단, 속성을 옵셔널로 선언하면 값이 없을경우 nil로 표현이 가능하므로 init을 사용할 필요가 없다.\nclass Cake { var name: String var price: Double init (a:String, b:Double) { name = a price = b } } // 생성자 미사용 시 var blueCake = Cake() blueCake.name = \u0026#34;블루케이크\u0026#34; blueCake.price = 4.0 // 생성자 사용 시 var blueCake = Cake(a: \u0026#34;블루케이크\u0026#34;, b: 4.0) Self. # 생성자가 파라미터로 받는 name과 price는 self.name를 초기화한다.\n생성자 내부의 self.name는 Cake 클래스를 이용해 만든 해당 객체의 var name에 담긴다.\nclass Cake { var name: String //var name: String? var price: Double init(name:String) { self.name = name self.price = price } } var blueCake = Cake(name: \u0026#34;블루케이크\u0026#34;) blueCake.name //블루케이크 blueCake 선언 시 init은 파라미터로 전달받은 name: \u0026quot;블루케이크\u0026quot;로 self.name을 초기화한다.\n이때 self.name은 곧 blueCake.name이다.\n"},{"id":5,"href":"/blog/docs/CS/Swift/property/","title":"여러가지 속성","section":"Swift","content":" Property # 저장속성 # 메모리 공간을 가지고 값을 저장할 수 있는 속성이다.\nClass Cake의 저장속성은 var name, var price !\nclass Cake { var name: String lazy var price: Double = 0.1 init (a:String) { name = a } } 지연저장속성(Lazy Stored Properties) # 속성의 초기화를 지연시키는 것으로, 해당 속성은 제외한 상태로 진행하다가 후에 접근 시 초기화하는 것이다.\n나중에 변화가 생기는 것이므로 var 로 선언해야며 미리 초기화 해두어야하는 것이 포인트!\n메모리 관리와 다른 속성을 이용(의존)해야하는 경우 사용한다!\nlazy var price: Double = 0.1 계산속성 # 계산속ㅇ실질적으로 함수이다!\n"}]