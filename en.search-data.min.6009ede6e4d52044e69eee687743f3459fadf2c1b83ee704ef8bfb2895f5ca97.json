[{"id":0,"href":"/blog/docs/ProductDesign/TheTribunus/Information/","title":"Information","section":"TheTribunus","content":"asd\n"},{"id":1,"href":"/blog/docs/CS/Algorithm/Information/","title":"PrefixSum_누적합","section":"Algorithm","content":"asd\n"},{"id":2,"href":"/blog/docs/ProductDesign/Sesac/Information/","title":"[1주차] 서비스 기획자 커리어","section":"SesacX러닝스푼즈 IT 서비스 기획자","content":" [1주차] 서비스 기획자 커리어 마인드 셋 # 서비스 기획 # 업무 단계, 실무에서의 사이클 # 현업자 분들에게 가장 궁금한 것은 역시나 실무가 어떤 사이클로 돌아가는지가 아닐까?\n실무 사이클 ### 1. 문제의 발견 - 직접 서비스를 이용해보면서 불편사항 찾기 - 구글, 네이버 등 타사에도 비슷한 기능이 있는지 마켓리서치 - 베치마킹 시 유명 서비스에서의 특정 페이지 또는 기능으로 범위를 한정 - 주니어 시절 아직 해당 서비스에 익숙하지 않을 때의 신선한 시선을 기억 2. 요구사항 분석 # 당장 해결이 불가능하더라도 분석서 형식으로 정리 후 사내 공유가 가능한 플랫폼에 아카이빙 동일한 불만사항이 수차례 접수되면 작업 우선순위를 높여서 진행 3. 상위기획 # 구체적인 정책과 방안을 정하는 과정 많은 요구사항 중 실제 진행할 프로젝트를 팀 회의로 결정 개발자와 협의를 위한 최초 문서로 작업 방향성을 공유 기능명세서, 메뉴구조도, 케이스별 정책 등의 자료가 추가되기도..! 4. 상세기획 # 표지 / 기획안 히스토리 / 개요 / 플로우차트 / 화면 세부 설명 등으로 진행. 협업하는 개발자/디자이너가 시니어/주니어인지에 따라 기획안의 디테일과 자세함이 달라짐. 기획안에 디자인을 하지말자! 협업자의 고유의 영역을 침범하지 말 것. 5. 개발 중 커뮤니케이션 # 범위가 모호하고 책임범위가 불분명한 경우 담당자(디자이너/개발자)와 무조건 협의하기. 6. QA 테스트 # 규모가 작은 스타트업에서는 기획자가 QA까지 진행하는 경우가 대부분. 본인이 작성한 기획안대로 구현되는지 테스트 진행 (웹, 모바일, 다양한 브라우저, 기종) 특히 카카오톡 인앱 브라우저나 네이버 인앱 브라우저 주의! 버그리포트 작성 시 화면 녹화 영상이나 오류사진을 첨부하면 더더욱 좋음! 7. 서비스 오픈 # 오픈 후 서비스 모니터링, 특히 테스트 당시 오류있었던 항목들 위주로 재점검. 오픈 후 7일 이내 프로젝트 회고 회의 진행. 범인찾기가 아닌 개선점을 찾는 시간으로! 개발자가 좋아하는 상세 기획안 # 명확할 것. 모호한 표현 없애기. 정해진 것, 변경 가능성 있는 것 기획안에 명시하기. (주로 데이터 구조에 연관된 것) 케이스별로 결과가 달리지는 기능이라면 플로우 차트로 도식화하기. 예외케이스들 # 이용자들은 기획자가 설계한 프로세스 순으로 서비스를 이용하지 않음. 우선 정상 시나리오 순으로 상세 기획안 작성 후 예외 케이스들 체크하기. 초기값, 노출방식, 글자 수 제한, 로딩 중, 삭제된 컨텐츠, 이용자별 권한, 키보드 액션 등. 실습 # 작성중\n출처 유니콘 기업 현직자에게 배우는 IT 서비스 기획자 취업 캠프 락홀릭 선생님의 서비스 기획자 커리어 마인드셋 / 서비스 기획 프로세스 수업\n"},{"id":3,"href":"/blog/docs/ProductDesign/SwimNearMe/Information/","title":"Information","section":"SwimNearMe","content":" 헤드라인 HeadLine # 헤드라인 2 # 헤드라인 3 # 헤드라인 4 # 안녕하세요 안녕하세요 hello hello\n#include\u0026lt;stdio.h\u0026gt; "},{"id":4,"href":"/blog/docs/CS/Swift/init/","title":"생성자","section":"Swift","content":" Initiallizer 생성자 # 클래스 안의 함수를 매서드라고 부르며, 매서드 중 클래스 안 저장 속성을 초기화하는 함수를 생성자 라고 부른다. 클래스가 품고있는 속성들이 많아질 경우 사용시 일일히 초기화하기 어렵기 때문에 우리는 초기화를 도와주는 생성자를 사용한다! init() 자동 구현 # 저장 속성의 기본값을 설정한 경우에는 스위프트에서 자동으로 init(생성자)를 구현해준다. 클래스로 인스턴스를 생성하는 var buleCake = Cake()는 사실 var blueCake = Cake.init()의 축약형. class Cake { var name: String = \u0026#34;블루케이크\u0026#34; var subname: String = \u0026#34;블루베리케이크\u0026#34; // 여기 숨어있지롱 // init() { // // } } var buleCake = Cake() Self. # 생성자가 파라미터로 받는 name과 price는 self.name를 초기화한다. 생성자 내부의 self.name는 Cake 클래스를 이용해 만든 해당 객체의 var name에 담긴다. blueCake 선언 시 init은 파라미터로 전달받은 name: \u0026quot;블루케이크\u0026quot;로 self.name을 초기화한다. 이때 self.name은 곧 blueCake.name이다. Overloading # 생성자도 매서드이므로 Overloading을 지원하므로, 클래스 안에 생성자를 맘대로맘대로 열매 먹은 것 마냥 생성할 수 있다. 장점은 개발자가 인스턴스를 만들 때 선택의 폭이 넓어진다는점? class Cake { var name: String //var name: String? var subname: String // 여러 저장 속성에 한가지 입력값을 넣을 수도 있고 init(name: String) { self.name = name self.subname = name } // 한번에 다 받을 수도 있다. init(name: String, subname: String, price: Double) { self.name = name self.subname = subname self.price = price } } Class Initiallizer 클래스 생성자 # 속성을 옵셔널로 선언하면 값이 없을경우 nil로 표현이 가능하므로 init을 사용할 필요가 없다. 1. Designated Initiallizer 지정 생성자 # 지정 생성자는 모든 속성을 초기화 해야한다. 일반적인 생성자를 지정 생성자라고 부르며, 그 범주 안에는 기본 생성자 init()도 포함되어있다.\n2. Convenience Initiallizer 편의 생성자 # 편의 생성자는 모든 속성을 초기화 할 필요가 없다. 편의 생성자는 상속되지 않으며, 서브클래스에서 재정의 할 수 없다. 지정 생성자를 베이스로 만들어낸 바리에이션. (편의)생성자 내에서 지정 생성자를 호출하는 것이 특징! 코드 중복을 없애 유지보수가 쉬워지며 특히 상속을 지원하는 클래스에선 저장 속성이 많아 실수가 나올 수 있는데 이를 방지해줌. 생성자 중복을 없애고 편의 생성자를 통해 지정 생성자를 호출해야한다!\nstruct Cake { let name, subname: String //편의 생성자 convenience init() { self.init(name: \u0026#34;블루케이크\u0026#34;, subname: \u0026#34;블루베리케이크\u0026#34;) } //편의 생성자 convenience init(name: String) { self.init(name: name, subname: name) } //지정 생성자 init(name: String, subname: String) { self.name = name self.subname = subname } } 3. 상속과 생성자 # 지정생성자를 선언한다. 이때, B클래스의 저장 속성인 var c를 설정해주어야함. 그리고 super.init() 즉, 상위 클래스인 A에서 만든 지정생성자를 호출한다. 이 위의 두가지 기본 세팅이다. 자기 자신의 저장속성을 설정하고, 상위 클래스의 지정생성자를 호출하는 것. 클래스 A를 상속해 만들어진 클래스 B가 있다고 해보자. B클래스에서 생성자를 활용하는 방법\nclass A { var a: Int var b: Int init(a: Int, b: Int) { self.a = a self.b = b } convenience init() { self.init(a: 0, b: 0) } } class B: A { var c: Int init(a: Int, b: Int, c: Int) { self.c = c //self.a = a 또는 self.b = b 처럼 //이때 여기서 A의 저장속성에 접근하는 것은 불가능하다. //왜냐? 아직 상위 클래스 A의 생성자를 호출하지 않아서 //해당 메모리 셋팅이 되기 전이기 때문이다. super.init(a: a, b: b) // 상위 지정 생성자 호출 //이 밑으로는 이제 A의 저장 속성에 접근이 가능하다. //self.a = 0 등 //메서드도 운용 가능함 } con } 구조체 생성자 # 구조체는 지정 생성자와 실패가능 생성자를 가질 수 있음.\n1. 구조체 지정 생성자 # 다른 생성자를 호출하는 생성자를 선언하는 방식도 가능하다. 이 경우는 클래스에서 편의 생성자에 해당한다. 물론 구조체는 클래스와 달리 편의 생성자라는 개념이 없으니 그냥 지정 생성자임. 장점은 코드 중복을 방지. 전체적인 생성자를 하나 만들고, 다른 생성자에서 해당 생성자를 가져오는 그런 방법.\nstruct Cake { let name, subname: String init() { self.init(name: \u0026#34;블루케이크\u0026#34;, subname: \u0026#34;블루베리케이크\u0026#34;) } init(name: String) { self.init(name: name, subname: name) } init(name: String, subname: String, price: Double) { self.name = name self.subname = subname self.price = price } } var buleCake = Cake() Memberwise Initializer # 구조체의 경우 맴버와이즈 이니셜라이저를 제공해줌. 생성자를 딱히 적지 않아도 xcode에서 알아서 구현해준다. 생성자를 당신이 새로 만들면 더 이상 안해줌\u0026hellip; 이런 이유? 클래스보다 구조체를 더 많이 쓰니까 허들을 낮춰준게 아닐까?\nstruct Cake { var name: String var price: Double // 여기 숨어있지롱 Xcode가 구현해주지롱.. 물론 당신이 새로 init을 생성하면 the end // init(name: String, subname: String, price: Double) { // self.name = name // self.subname = subname // self.price = price // } } //var blueCake = Cake(name: String, price: Double) "},{"id":5,"href":"/blog/docs/CS/Swift/property/","title":"여러가지 속성","section":"Swift","content":" Property # 1. 저장 속성 # 메모리 공간을 가지고 값을 저장할 수 있는 속성. Class Cake의 저장속성은 var name, var price !\nclass Cake { var name: String lazy var price: Double = 0.1 init (a:String) { name = a } } 2. 지연 저장 속성(Lazy Stored Properties) # 속성의 초기화를 지연시키는 것으로, 해당 속성은 제외한 상태로 진행하다가 후에 접근 시 초기화하는 것임. 나중에 변화가 생기는 것이므로 var 로 선언해야며 미리 초기화 해두어야하는 것이 포인트! 지연 저장 속성 운용 시 생성자 안에서는 따로 값 설정을 해주지 않아야 함. 메모리 관리와 다른 속성을 이용(의존)해야하는 경우 사용한다!\nlazy var price: Double = 0.1 3. 계산 속성 # 계산속성은 실질적으로 함수이며 get 속성과 set 속성으로 나누어진다. 두가지 매서드를 한번에 구현할 수 있으며, 결국 속성의 탈을 쓴 매서드임! addScore는 score에 의존한다.\nclass score { var score: Int = 0 var addScore: Int { get { return score + 100 } set(newValue) { self.score = score + newValue } } } var peter = scoreCal() peter.score = 100 peter.addScore //200 peter.addScore = 500 peter.score //600 get # get은 값을 얻는 것. peter.score 실행 시 내부의 get으로 들어가 score + 100 값을 리턴한다. set과 함께 쓰이지 않을 경우 get 블록으로 감싸지 않아도 괜찮다!\nclass score { var score: Int = 0 var addScore: Int { return score + 100 } } set # set은 값을 세팅하는 것. get이 정해진 과정을 수행한다면 set은 사용자가 외부에서 값을 세팅하는 과정을 수행하며 peter.addScore=500의 의미는 peter.score = score + 500 을 의미한다. 파라미터는 newVaule로 사용하기로 애플과의 약속이다 :) 또한 생략도 가능하다.\nclass score { var score: Int = 0 var addScore: Int { get { return score + 100 } set { self.score = score + newValue } } } 4. 타입 속성 # 모든 인스턴스가 공통적으로 가져야하는 속성의 경우 사용한다. 클래스, 구조체 등에 모두 사용가능하며, 접근 시 인스턴스가 아닌 클래스 원본에 접근해야 알아낼 수 있다. 따로 Student()를 사용해 인스턴스 생성을 하지 않아도 접근할 수 있다! init(생성자)을 통해 따로 초기화하는 과정이 없으므로 선언시 무조건 초기값을 지정해주어야한다.\n저장 타입 속성 # 활용 방법에 있어서는 static var count: Int = 0으로 타입속성을 초기화하고, init 구문 안에 Student.count += 1을 통해서 Student로 만들어진 인스턴스의 총 갯수를 샐 수 있다.\nclass Student { static let standing: String = \u0026#34;학생\u0026#34; static var count: Int = 0 //인스턴스를 몇개 찍어냈는지 확인 var name: String init(name:String, score: Int) { self.name = name self.score = score Student.count += 1 // 타입 속성의 활용 } } let student = Student(name: \u0026#34;길동\u0026#34;, score: 60) student.name //길동 student.score //60 //타입속성 접근 시 (static에 접근 시) Student.standing //student.standing 은 에러 발생 계산 타입 속성 # 계산 타입 속성의 경우 static 사용시 상속에서 재정의가 불가능하지만, class 사용시 재정의가 가능하다.\nclass Student { static let standing: String = \u0026#34;학생\u0026#34; static let score: Int = 0 //계산 타입 속성 예시 static var plusScore: Int { return score + 100 } //상속 재정의가 가능 class var pulsScore2: Int { return score +100 } } 5. 속성 감시자 # 저장 속성과 속성의 변화를 감시하는 매서드이며, 저장 속성이 변경되면 호출된다. 계산 속성에도 사용 가능하나, 상속해서 재정의하는 경우에만 가능하다. 사실 계산 속성의 경우 set 블록에서 속성의 변화를 감지할 수 있으므로… 속성감시자는 저장 속성에 자주 쓰인다고만 알아두자.\nclass Student { var name: String = \u0026#34;이름\u0026#34; //저장속성과 해당 속성이 변하는 시점을 관찰하는 매서드 var status: String = \u0026#34;재학생\u0026#34; { willSet(newValue) { print(\u0026#34;\\(name) 학생 : \\(status)에서 \\(newValue)로 변경 예정\u0026#34;) } didSet(oldValue) { print(\u0026#34;\\(name) 학생 : \\(oldValue)에서 \\(status)로 변경 완료\u0026#34;) } } init(name: String) { self.name = name } } let std01 = Student(name: \u0026#34;길동\u0026#34;) std01.status = \u0026#34;졸업생\u0026#34; // 길동 학생 : 재학생에서 졸업생으로 변경예정 // 길동 학생 : 재학생에서 졸업생으로 변경예정 willset # willset은 메모리 변경(저장 속성 변경) 직전에 호출된다. 따라서 파라미터로 받는 정보는 메모리 변경 전 기본 세팅 값 되시겠다. 기본적으로 newValue 파라미터를 사용하며 생략 또한 가능하다.\nwillSet { print(\u0026#34;\\(name) 학생 : \\(status)에서 \\(newValue)로 변경 예정\u0026#34;) } didSet # didSet은 메모리 변경(저장 속성 변경) 직후에 호출된다. 따라서 파라미터로 받는 정보 또한 메모리 변경 이후 값 되시겠다. 기본적으로 oldValue 파라미터를 사용하며 생략 또한 가능하다.\ndidSet { print(\u0026#34;\\(name) 학생 : \\(oldValue)에서 \\(status)로 변경 완료\u0026#34;) } "}]